# SCRIPT Command Expression Support Plan

## Overview

Enable dynamic script selection using expressions like `SCRIPT SEQ 1 2 3`.

## Current State

### Current Implementation

**Location:** `src/commands/system/misc.rs:329-355`

Current behavior:
- Accepts exactly 1 argument (enforced in validation)
- Supports expressions via `eval_expression()` for single values
- Returns script index to execute (1-8 → 0-7)

**Validation constraint:** `src/commands/validate.rs:709-714`
```rust
// Enforces argc == 1
"SCRIPT TAKES EXACTLY 1 ARGUMENT"
```

### What Already Works

```
SCRIPT 1              # Static - works
SCRIPT A              # Variable - works (if A=1-8)
SCRIPT + A 1          # Math expression - works
```

### What Doesn't Work

```
SCRIPT SEQ 1 2 3      # Fails validation (>1 arg)
SCRIPT SEQ "1 2 3"    # Fails (but almost works!)
```

## The Gap

SEQ expressions require:
1. The keyword `SEQ`
2. A quoted pattern string: `"1 2 3"`

But SCRIPT validation rejects multi-argument input.

## Implementation Options

### Option A: Allow Quoted SEQ (Recommended)

Support: `SCRIPT SEQ "1 2 3"`

**Changes:**

1. **Update validation** (`src/commands/validate.rs`):
```rust
// Change from:
if argc != 1 { error }
// To:
if argc < 1 { error }
// Allow 1+ arguments for SEQ support
```

2. **Update handler** (`src/commands/system/misc.rs`):
```rust
// Already handles eval_expression which supports SEQ
// Just need validation to allow the args through
```

3. **Help text update**:
```
SCRIPT <1-8|expr>     EXEC SCRIPT
                      expr: SEQ "1 2 3", + A 1, etc
```

### Option B: Unquoted Multi-Arg SEQ

Support: `SCRIPT SEQ 1 2 3` (no quotes)

**Changes:**

1. **Detect SEQ keyword in handler**:
```rust
if parts.len() > 2 && parts[1] == "SEQ" {
    // Construct quoted string from remaining args
    let seq_pattern = parts[2..].join(" ");
    // Evaluate as SEQ "pattern"
}
```

2. **More invasive** - requires special-casing SEQ parsing

### Option C: Expression Wrapper

Support: `SCRIPT (SEQ "1 2 3")`

**Changes:**
- Add parentheses support to expression parser
- Cleanest semantically but most work

## Recommended Implementation (Option A)

### Task 1: Relax Validation

**File:** `src/commands/validate.rs`

```rust
// Line ~709
"SCRIPT" => {
    if argc < 1 {
        return Err("SCRIPT REQUIRES AT LEAST 1 ARGUMENT".to_string());
    }
    // Validate first arg is valid script ref OR expression keyword
    if argc == 1 {
        validate_script_reference(parts[1])?;
    }
    // Multi-arg case handled by eval_expression in handler
    Ok(())
}
```

### Task 2: Verify Handler Supports Multi-Arg

**File:** `src/commands/system/misc.rs`

The existing `eval_expression()` call should handle SEQ:
```rust
let num: usize = if let Some((expr_val, _)) = eval_expression(
    &parts, 1, variables, patterns, counters, scripts, script_index, scale
) {
    // This already supports SEQ "pattern" via eval/seq.rs
    expr_val as usize
} else {
    parts[1].parse()?
};
```

Verify `eval_expression` passes remaining parts correctly.

### Task 3: Add Tests

Test cases:
```
SCRIPT 1                    # Basic
SCRIPT A                    # Variable (A=3)
SCRIPT + A 1                # Math (A=2 → 3)
SCRIPT SEQ "1 2 3 4"        # SEQ cycles 1→2→3→4→1...
SCRIPT SEQ "1 8"            # SEQ alternates 1↔8
SCRIPT EITH "1 4"           # Random choice
```

### Task 4: Update Help

**File:** `src/ui/pages/help_content.rs`

```
SCRIPT <1-8|expr>     EXEC SCRIPT
  SCRIPT 3            execute script 3
  SCRIPT A            execute script in var A
  SCRIPT SEQ "1 2 3"  cycle through scripts
```

## Files to Modify

| File | Changes |
|------|---------|
| `src/commands/validate.rs` | Relax argc check |
| `src/commands/system/misc.rs` | Verify multi-arg handling |
| `src/ui/pages/help_content.rs` | Document expression support |
| `docs/MANUAL.md` | Add examples |

## Testing

1. Static script numbers still work
2. Variable references work
3. Math expressions work
4. SEQ with quoted pattern cycles correctly
5. EITH random selection works
6. Error on invalid script numbers (0, 9+)
